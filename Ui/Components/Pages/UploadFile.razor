@page "/uploadingFiles"
@attribute [Authorize]
@inject IHttpClientFactory HttpClientFactory
@inject IJSRuntime JS
@using System.Text.Json
@using Share.DTOs
@using Ui.Components.Helper

<PageTitle>Загрузка файлов</PageTitle>

<div class="container mt-5">
    <div class="card shadow-sm">
        <div class="card-header bg-primary text-white">
            <h3 class="mb-0">Загрузка Excel файла</h3>
        </div>
        <div class="card-body">
            @if (!string.IsNullOrEmpty(errorMessage))
            {
                <div class="alert alert-danger alert-dismissible fade show" role="alert">
                    <strong>Ошибка!</strong> @errorMessage
                    <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Закрыть"></button>
                </div>
            }

            @if (errorList != null && errorList.Count > 0)
            {
                <div class="alert alert-danger alert-dismissible fade show" role="alert">
                    <strong>Ошибки:</strong>
                    <ul class="mb-0">
                        @foreach (var error in errorList)
                        {
                            <li>@error</li>
                        }
                    </ul>
                    <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Закрыть"></button>
                </div>
            }

            @if (!string.IsNullOrEmpty(successMessage))
            {
                <div class="alert alert-success alert-dismissible fade show" role="alert">
                    @successMessage
                    <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Закрыть"></button>
                </div>
            }

            <div class="mb-3">
                <label for="fileInput" class="form-label">Выберите Excel файл для загрузки</label>
                <InputFile id="fileInput" OnChange="OnInputFileChange" class="form-control" accept=".xlsx, .xls" />
                @if (selectedFile != null)
                {
                    <div class="mt-2">
                        <span>Выбран файл: <strong>@selectedFile.Name</strong> (@(selectedFile.Size / 1024) KB)</span>
                    </div>
                }
            </div>

            <div class="d-flex gap-2">
                <button class="btn btn-primary" @onclick="SubmitFile" disabled="@(!CanSubmit)">
                    <span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true" hidden="@(!isSubmitting)"></span>
                    Загрузить
                </button>
                @if (fileUploaded)
                {
                    <button class="btn btn-success" @onclick="ProcessFile" disabled="@(!fileUploaded || isProcessing)">
                        <span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true" hidden="@(!isProcessing)"></span>
                        Обработать
                    </button>
                    <button class="btn btn-secondary" @onclick="DownloadFile" disabled="@(!fileProcessed || isDownloading)">
                        <span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true" hidden="@(!isDownloading)"></span>
                        Скачать
                    </button>
                }
            </div>
        </div>
    </div>
</div>

<style>
    .spinner-border-sm {
        width: 1rem;
        height: 1rem;
    }

    .alert ul {
        margin-bottom: 0;
        padding-left: 1.25rem;
    }

    @@media (max-width: 576px) {
        .container {
            padding: 0 15px;
        }
    }
</style>

<script>
    function saveAsFile(filename, byteBase64) {
        const blob = new Blob([new Uint8Array(atob(byteBase64).split("").map(char => char.charCodeAt(0)))]);
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
    }
</script>

@code {
    private IBrowserFile selectedFile;
    private string errorMessage;
    private string successMessage;
    private List<string> errorList = new();
    private int uploadFileInfId;
    private bool fileUploaded = false;
    private bool fileProcessed = false;
    private bool isSubmitting = false;
    private bool isProcessing = false;
    private bool isDownloading = false;

    private bool CanSubmit => selectedFile != null && !isSubmitting;

    private void OnInputFileChange(InputFileChangeEventArgs e)
    {
        selectedFile = e.File;
        // Сброс состояния после выбора нового файла
        errorMessage = string.Empty;
        successMessage = string.Empty;
        errorList.Clear();
        fileUploaded = false;
        fileProcessed = false;
    }

    private async Task SubmitFile()
    {
        if (selectedFile == null)
        {
            errorMessage = "Пожалуйста, выберите файл для загрузки.";
            return;
        }

        errorMessage = string.Empty;
        successMessage = string.Empty;
        errorList.Clear();
        isSubmitting = true;

        var Http = HttpClientFactory.CreateClient("BackendAPI");

        try
        {
            var content = new MultipartFormDataContent();
            var fileStream = selectedFile.OpenReadStream(maxAllowedSize: 10 * 1024 * 1024); // Ограничение размера файла (например, 10 МБ)
            var streamContent = new StreamContent(fileStream);
            streamContent.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue(selectedFile.ContentType);
            content.Add(streamContent, "file", selectedFile.Name);

            var response = await Http.PostAsync("api/SpiskiNaDDFromMO/upload", content);
            var responseContent = await response.Content.ReadAsStringAsync();

            if (response.IsSuccessStatusCode)
            {
                var uploadResponse = JsonSerializer.Deserialize<UploadResponse>(responseContent, new JsonSerializerOptions { PropertyNameCaseInsensitive = true });
                if (uploadResponse != null)
                {
                    uploadFileInfId = uploadResponse.UploadFileId;
                    fileUploaded = true;
                    successMessage = "Файл успешно загружен!";
                }
            }
            else
            {
                HandleErrorResponse(responseContent);
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Произошла ошибка при загрузке файла: {ex.Message}";
        }
        finally
        {
            isSubmitting = false;
        }
    }

    private async Task ProcessFile()
    {
        if (uploadFileInfId <= 0)
        {
            errorMessage = "Файл был загружен некорректно.";
            return;
        }

        errorMessage = string.Empty;
        successMessage = string.Empty;
        errorList.Clear();
        isProcessing = true;

        var Http = HttpClientFactory.CreateClient("BackendAPI");
        try
        {
            var response = await Http.PostAsync($"api/DispensaryList/process/{uploadFileInfId}", null);
            var responseContent = await response.Content.ReadAsStringAsync();

            if (response.IsSuccessStatusCode)
            {
                successMessage = "Процесс обработки завершен успешно!";
                fileProcessed = true;
            }
            else
            {
                HandleErrorResponse(responseContent);
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Произошла ошибка при обработке файла: {ex.Message}";
        }
        finally
        {
            isProcessing = false;
        }
    }

    private async Task DownloadFile()
    {
        if (uploadFileInfId <= 0)
        {
            errorMessage = "Файл не был загружен корректно.";
            return;
        }

        errorMessage = string.Empty;
        isDownloading = true;

        var Http = HttpClientFactory.CreateClient("BackendAPI");
        try
        {
            var response = await Http.GetAsync($"api/DispensaryList/download/{uploadFileInfId}");

            if (response.IsSuccessStatusCode)
            {
                var fileStream = await response.Content.ReadAsStreamAsync();
                using var memoryStream = new MemoryStream();
                await fileStream.CopyToAsync(memoryStream);

                var fileBytes = memoryStream.ToArray();
                var base64String = Convert.ToBase64String(fileBytes);

                var fileName = "DispensaryListResults.xlsx";
                await JS.InvokeVoidAsync("saveAsFile", fileName, base64String);
                successMessage = "Файл успешно скачан!";
            }
            else
            {
                errorMessage = "Ошибка при скачивании файла.";
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Произошла ошибка при скачивании файла: {ex.Message}";
        }
        finally
        {
            isDownloading = false;
        }
    }

    private void HandleErrorResponse(string responseContent)
    {
        try
        {
            var errorResponse = JsonSerializer.Deserialize<ErrorResponse>(responseContent, new JsonSerializerOptions { PropertyNameCaseInsensitive = true });
            if (errorResponse != null && errorResponse.Errors != null && errorResponse.Errors.Any())
            {
                errorList = errorResponse.Errors;
                errorMessage = errorResponse.Message ?? "На сервере произошли ошибки.";
            }
            else
            {
                errorMessage = "Произошла неизвестная ошибка.";
            }
        }
        catch
        {
            errorMessage = "Не удалось разобрать ответ с ошибкой.";
        }
    }

    private class ProcessResponse
    {
        public bool Success { get; set; }
        public string Message { get; set; }
    }

    private class UploadResponse
    {
        public int UploadFileId { get; set; }
    }

    private class ErrorResponse
    {
        public string Message { get; set; }
        public List<string> Errors { get; set; }
    }
}
